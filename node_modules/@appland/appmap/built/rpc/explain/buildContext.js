"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const models_1 = require("@appland/models");
const assert_1 = __importDefault(require("assert"));
const sequenceDiagram_1 = require("../appmap/sequenceDiagram");
const lookupSourceCode_1 = __importDefault(require("./lookupSourceCode"));
const console_1 = require("console");
/**
 * Processes search results to build sequence diagrams, code snippets, and code object sets. This is the format
 * expected by the Navie AI.
 *
 * Given a list of search results, `buildContext` asynchronously:
 *
 * - Generates sequence diagrams for each result using event data and a filtered appmap,
 *   formatting the output as PlantUML and storing it in an array. The filtered sequence diagram
 *   includes only the code objects associated with the events in the search result, and their near neighbors.
 *
 * - Collects and de-duplicates code snippets tied to specific events' locations, storing them in a map with the location as the key.
 *
 * - Gathers a set of unique code objects identified by their fully qualified identifiers (fqid) from the events.
 *   These code objects are most commonly SQL queries and HTTP requests (client and server), since code snipptes are stored separately.
 *   The term "data requests" is being phased in to replace "codeObjects".
 */
async function buildContext(searchResults) {
    const sequenceDiagrams = new Array();
    const codeSnippets = new Map();
    const codeObjects = new Set();
    const buildSequenceDiagram = async (result) => {
        const codeObjects = result.events.map((event) => event.fqid);
        const appmapFilter = new models_1.AppMapFilter();
        appmapFilter.declutter.context.on = true;
        appmapFilter.declutter.context.names = codeObjects;
        const filterState = (0, models_1.serializeFilter)(appmapFilter);
        const plantUML = await (0, sequenceDiagram_1.handler)(result.appmap, {
            filter: filterState,
            format: 'plantuml',
            formatOptions: { disableMarkup: true },
        });
        (0, assert_1.default)(typeof plantUML === 'string');
        sequenceDiagrams.push(plantUML);
    };
    const examinedLocations = new Set();
    for (const result of searchResults) {
        try {
            await buildSequenceDiagram(result);
        }
        catch (e) {
            (0, console_1.warn)(`Failed to build sequence diagram for ${result.appmap}`);
            (0, console_1.warn)(e);
        }
        for (const event of result.events) {
            if (!event.location) {
                codeObjects.add(event.fqid);
                continue;
            }
            if (examinedLocations.has(event.location))
                continue;
            examinedLocations.add(event.location);
            if (codeSnippets.has(event.location))
                continue;
            const snippets = await (0, lookupSourceCode_1.default)(result.directory, event.location);
            if (snippets) {
                codeSnippets.set(event.location, snippets.join('\n'));
            }
        }
    }
    return { sequenceDiagrams, codeSnippets, codeObjects };
}
exports.default = buildContext;
//# sourceMappingURL=buildContext.js.map