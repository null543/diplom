"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContextCollector = exports.EventCollector = exports.textSearchResultToRpcSearchResult = void 0;
const AppMapIndex_1 = __importDefault(require("../../fulltext/AppMapIndex"));
const FindEvents_1 = __importDefault(require("../../fulltext/FindEvents"));
const search_1 = require("../search/search");
const buildContext_1 = __importDefault(require("./buildContext"));
const console_1 = require("console");
const path_1 = require("path");
function textSearchResultToRpcSearchResult(eventResult) {
    const result = {
        fqid: eventResult.fqid,
        score: eventResult.score,
        eventIds: eventResult.eventIds,
    };
    if (eventResult.location)
        result.location = eventResult.location;
    if (eventResult.elapsed)
        result.elapsed = eventResult.elapsed;
    return result;
}
exports.textSearchResultToRpcSearchResult = textSearchResultToRpcSearchResult;
class EventCollector {
    constructor(query, appmapSearchResponse) {
        this.query = query;
        this.appmapSearchResponse = appmapSearchResponse;
        this.appmapIndexes = new Map();
    }
    async collectEvents(maxEvents) {
        const results = new Array();
        for (const result of this.appmapSearchResponse.results) {
            let { appmap } = result;
            if (!(0, path_1.isAbsolute)(appmap))
                appmap = (0, path_1.join)(result.directory, appmap);
            const eventsSearchResponse = await this.findEvents(appmap, maxEvents);
            results.push({
                appmap: appmap,
                directory: result.directory,
                events: eventsSearchResponse.results.map(textSearchResultToRpcSearchResult),
                score: result.score,
            });
        }
        const context = await (0, buildContext_1.default)(results);
        const contextSize = context.sequenceDiagrams.join('').length +
            Array.from(context.codeSnippets.values()).join('').length +
            [...context.codeObjects].join('').length;
        return { results, context, contextSize };
    }
    async appmapIndex(appmap) {
        let index = this.appmapIndexes.get(appmap);
        if (!index) {
            index = new FindEvents_1.default(appmap);
            await index.initialize();
            this.appmapIndexes.set(appmap, index);
        }
        return index;
    }
    async findEvents(appmap, maxResults) {
        if (appmap.endsWith('.appmap.json'))
            appmap = appmap.slice(0, -'.appmap.json'.length);
        const index = await this.appmapIndex(appmap);
        return index.search(this.query, { maxResults });
    }
}
exports.EventCollector = EventCollector;
class ContextCollector {
    constructor(directories, vectorTerms, charLimit) {
        this.directories = directories;
        this.vectorTerms = vectorTerms;
        this.charLimit = charLimit;
        this.query = vectorTerms.join(' ');
    }
    async collectContext() {
        const query = this.vectorTerms.join(' ');
        let appmapSearchResponse;
        if (this.appmaps) {
            const results = this.appmaps
                .map((appmap) => {
                const directory = this.directories.find((dir) => appmap.startsWith(dir));
                if (!directory)
                    return undefined;
                return {
                    appmap,
                    directory,
                    score: 1,
                };
            })
                .filter(Boolean);
            appmapSearchResponse = {
                type: 'appmap',
                stats: {
                    max: 1,
                    mean: 1,
                    median: 1,
                    stddev: 0,
                },
                results,
                numResults: this.appmaps.length,
            };
        }
        else {
            // Search across all AppMaps, creating a map from AppMap id to AppMapSearchResult
            const searchOptions = {
                maxResults: search_1.DEFAULT_MAX_DIAGRAMS,
            };
            appmapSearchResponse = await AppMapIndex_1.default.search(this.directories, query, searchOptions);
        }
        const eventsCollector = new EventCollector(this.query, appmapSearchResponse);
        let contextCandidate;
        let charCount = 0;
        let maxEventsPerDiagram = 5;
        (0, console_1.log)(`Requested char limit: ${this.charLimit}`);
        while (true) {
            (0, console_1.log)(`Collecting context with ${maxEventsPerDiagram} events per diagram.`);
            contextCandidate = await eventsCollector.collectEvents(maxEventsPerDiagram);
            const estimatedSize = contextCandidate.contextSize;
            (0, console_1.log)(`Collected an estimated ${estimatedSize} characters.`);
            if (estimatedSize === charCount || estimatedSize > this.charLimit) {
                break;
            }
            charCount = estimatedSize;
            maxEventsPerDiagram = Math.ceil(maxEventsPerDiagram * 1.5);
            (0, console_1.log)(`Increasing max events per diagram to ${maxEventsPerDiagram}.`);
        }
        return {
            searchResponse: {
                results: contextCandidate.results,
                numResults: appmapSearchResponse.numResults,
            },
            context: contextCandidate.context,
        };
    }
}
exports.ContextCollector = ContextCollector;
async function collectContext(directories, appmaps, vectorTerms, charLimit) {
    const contextCollector = new ContextCollector(directories, vectorTerms, charLimit);
    if (appmaps)
        contextCollector.appmaps = appmaps;
    return contextCollector.collectContext();
}
exports.default = collectContext;
//# sourceMappingURL=collectContext.js.map