"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.explainStatusHandler = exports.explainHandler = exports.Explain = exports.DEFAULT_TOKEN_LIMIT = void 0;
const chalk_1 = __importDefault(require("chalk"));
const assert_1 = __importDefault(require("assert"));
const events_1 = __importDefault(require("events"));
const rpc_1 = require("@appland/rpc");
const console_1 = require("console");
const rpc_2 = require("../rpc");
const collectContext_1 = __importDefault(require("./collectContext"));
const configuration_1 = __importDefault(require("../configuration"));
const projectInfo_1 = __importDefault(require("../../cmds/navie/projectInfo"));
const help_1 = __importDefault(require("../../cmds/navie/help"));
const searchStatusByUserMessageId = new Map();
exports.DEFAULT_TOKEN_LIMIT = 8000;
class Explain extends events_1.default {
    constructor(directories, question, codeSelection, appmaps, status) {
        super();
        this.directories = directories;
        this.question = question;
        this.codeSelection = codeSelection;
        this.appmaps = appmaps;
        this.status = status;
    }
    async explain(navie) {
        const self = this;
        navie.on('ack', (userMessageId, threadId) => {
            this.status.threadId = threadId;
            this.emit('ack', userMessageId, threadId);
        });
        navie.on('token', (token, _messageId) => {
            var _a;
            (_a = this.status).explanation || (_a.explanation = []);
            this.status.explanation.push(token);
        });
        navie.on('complete', () => {
            this.status.step = rpc_1.ExplainRpc.Step.COMPLETE;
            this.emit('complete');
        });
        navie.on('error', (err) => {
            this.status.step = rpc_1.ExplainRpc.Step.ERROR;
            const rpcError = rpc_2.RpcError.fromException(err);
            if (!this.status.err)
                this.status.err = {
                    code: rpcError.code,
                    message: rpcError.message,
                    stack: err.stack,
                    cause: err.cause,
                };
            this.emit('error', rpcError);
        });
        await navie.ask(this.question, this.codeSelection);
    }
    async searchContext(data) {
        const { vectorTerms } = data;
        let { tokenCount } = data;
        if (!tokenCount) {
            (0, console_1.warn)(chalk_1.default.bold(`Warning: tokenCount not set, defaulting to ${exports.DEFAULT_TOKEN_LIMIT}`));
            tokenCount = exports.DEFAULT_TOKEN_LIMIT;
        }
        this.status.vectorTerms = vectorTerms;
        this.status.step = rpc_1.ExplainRpc.Step.SEARCH_APPMAPS;
        // TODO: More accurate char limit? Probably doesn't matter because they will be
        // pruned by the client AI anyway.
        // The meaning of tokenCount is "try and get at least this many tokens"
        const charLimit = tokenCount * 3;
        const searchResult = await (0, collectContext_1.default)(this.directories, this.appmaps, vectorTerms, charLimit);
        this.status.searchResponse = searchResult.searchResponse;
        this.status.step = rpc_1.ExplainRpc.Step.COLLECT_CONTEXT;
        this.status.sequenceDiagrams = searchResult.context.sequenceDiagrams;
        this.status.codeSnippets = Array.from(searchResult.context.codeSnippets.keys()).reduce((acc, key) => {
            const snippet = searchResult.context.codeSnippets.get(key);
            (0, assert_1.default)(snippet !== undefined);
            if (snippet)
                acc[key] = snippet;
            return acc;
        }, {});
        this.status.codeObjects = Array.from(searchResult.context.codeObjects);
        this.status.step = rpc_1.ExplainRpc.Step.EXPLAIN;
        return {
            sequenceDiagrams: this.status.sequenceDiagrams,
            codeSnippets: this.status.codeSnippets,
            codeObjects: this.status.codeObjects,
        };
    }
    projectInfoContext() {
        return (0, projectInfo_1.default)();
    }
    helpContext(data) {
        return (0, help_1.default)(data);
    }
}
exports.Explain = Explain;
async function explain(navieProvider, question, codeSelection, appmaps, threadId) {
    const status = {
        step: rpc_1.ExplainRpc.Step.NEW,
        threadId,
    };
    const { directories } = (0, configuration_1.default)();
    const explain = new Explain(directories, question, codeSelection, appmaps, status);
    const invokeContextFunction = async (data) => {
        const type = data['type'];
        const fnName = [type, 'Context'].join('');
        (0, console_1.warn)(`Explain received context request: ${type}`);
        const fn = explain[fnName];
        if (!fn) {
            (0, console_1.warn)(`Explain context function ${fnName} not found`);
            return {};
        }
        try {
            return await fn.call(explain, data);
        }
        catch (e) {
            (0, console_1.warn)(`Explain context function ${fnName} threw an error:`);
            (0, console_1.warn)(e);
            return {};
        }
    };
    const contextProvider = async (data) => invokeContextFunction(data);
    const projectInfoProvider = async (data) => invokeContextFunction(data);
    const helpProvider = async (data) => invokeContextFunction(data);
    const navie = navieProvider(threadId, contextProvider, projectInfoProvider, helpProvider);
    return new Promise((resolve, reject) => {
        let isFirst = true;
        const first = () => {
            if (isFirst) {
                isFirst = false;
                return true;
            }
            return false;
        };
        // TODO: These could be collected into status errors
        explain.on('error', (err) => first() && reject(rpc_2.RpcError.fromException(err)));
        explain.on('ack', (userMessageId, threadId) => {
            status.threadId = threadId;
            const cleanupFn = () => searchStatusByUserMessageId.delete(userMessageId);
            setTimeout(cleanupFn, 1000 * 60 * 5).unref();
            searchStatusByUserMessageId.set(userMessageId, status);
            first() && resolve({ userMessageId, threadId });
        });
        // If the request completes here, consider it an error. This would mean that the
        // remote server terminated our connection early.
        explain.on('complete', () => {
            var _a;
            return first() &&
                reject(rpc_2.RpcError.fromException(new Error(((_a = status.explanation) === null || _a === void 0 ? void 0 : _a.join('')) || 'The response completed unexpectedly')));
        });
        explain.explain(navie).catch((err) => first() && reject(rpc_2.RpcError.fromException(err)));
    });
}
const explainHandler = (navieProvider) => {
    return {
        name: rpc_1.ExplainRpc.ExplainFunctionName,
        handler: async (options) => await explain(navieProvider, options.question, options.codeSelection, options.appmaps, options.threadId),
    };
};
exports.explainHandler = explainHandler;
const explainStatusHandler = () => {
    return {
        name: rpc_1.ExplainRpc.ExplainStatusFunctionName,
        handler: async (options) => {
            const searchStatus = searchStatusByUserMessageId.get(options.userMessageId);
            if (!searchStatus)
                throw new rpc_2.RpcError(404, `No search request with id ${options.userMessageId}`);
            return searchStatus;
        },
    };
};
exports.explainStatusHandler = explainStatusHandler;
//# sourceMappingURL=explain.js.map