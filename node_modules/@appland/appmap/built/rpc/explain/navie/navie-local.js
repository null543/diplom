"use strict";
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const console_1 = require("console");
const events_1 = __importDefault(require("events"));
const promises_1 = require("fs/promises");
const crypto_1 = require("crypto");
const path_1 = require("path");
const os_1 = require("os");
const navie_1 = require("@appland/navie");
class LocalHistory {
    constructor(threadId) {
        this.threadId = threadId;
    }
    async saveMessage(message) {
        if (!['user', 'assistant'].includes(message.role))
            throw new Error(`Invalid message role for conversation history : ${message.role}`);
        await this.initHistory();
        const timestampNumber = Date.now();
        const historyFile = (0, path_1.join)(this.historyDir, `${timestampNumber}.json`);
        await (0, promises_1.writeFile)(historyFile, JSON.stringify(message, null, 2));
    }
    async restoreMessages() {
        await this.initHistory();
        const historyFiles = (await (0, promises_1.readdir)(this.historyDir)).sort();
        const history = [];
        for (const historyFile of historyFiles) {
            const historyPath = (0, path_1.join)(this.historyDir, historyFile);
            const historyString = await (0, promises_1.readFile)(historyPath, 'utf-8');
            const message = JSON.parse(historyString);
            // Fix messages that were miscategorized.
            if (message.role === 'system') {
                message.role = 'assistant';
            }
            history.push(message);
        }
        return history;
    }
    async initHistory() {
        await (0, promises_1.mkdir)(this.historyDir, { recursive: true });
    }
    get historyDir() {
        return (0, path_1.join)((0, os_1.homedir)(), '.appmap', 'navie', 'history', this.threadId);
    }
}
const OPTION_SETTERS = {
    tokenLimit: (explainOptions, value) => {
        explainOptions.tokenLimit = typeof value === 'string' ? parseInt(value, 10) : value;
    },
    temperature: (explainOptions, value) => {
        explainOptions.temperature = typeof value === 'string' ? parseFloat(value) : value;
    },
    modelName: (explainOptions, value) => {
        explainOptions.modelName = String(value);
    },
    explainMode: (explainOptions, value) => {
        explainOptions.agentMode = value;
    },
};
class LocalNavie extends events_1.default {
    constructor(threadId, contextProvider, projectInfoProvider, helpProvider) {
        super();
        this.threadId = threadId;
        this.contextProvider = contextProvider;
        this.projectInfoProvider = projectInfoProvider;
        this.helpProvider = helpProvider;
        this.explainOptions = new navie_1.Explain.ExplainOptions();
        if (threadId) {
            (0, console_1.log)(`[local-navie] Continuing thread ${threadId}`);
            this.threadId = threadId;
        }
        else {
            this.threadId = (0, crypto_1.randomUUID)();
            (0, console_1.log)(`[local-navie] Starting new thread ${this.threadId}`);
        }
        this.threadId = threadId || (0, crypto_1.randomUUID)();
        this.history = new LocalHistory(this.threadId);
    }
    setOption(key, value) {
        const setter = OPTION_SETTERS[key];
        if (setter) {
            setter(this.explainOptions, value);
        }
        else {
            throw new Error(`LocalNavie does not support option '${key}'`);
        }
    }
    async ask(question, codeSelection) {
        var _a, e_1, _b, _c;
        const messageId = (0, crypto_1.randomUUID)();
        (0, console_1.log)(`[local-navie] Processing question ${messageId} in thread ${this.threadId}`);
        this.emit('ack', messageId, this.threadId);
        const clientRequest = {
            question,
            codeSelection,
        };
        const history = await this.history.restoreMessages();
        this.history.saveMessage({ content: question, role: 'user' });
        const explainFn = (0, navie_1.explain)(clientRequest, this.contextProvider, this.projectInfoProvider, this.helpProvider, this.explainOptions, history);
        explainFn.on('event', (event) => this.emit('event', event));
        const response = new Array();
        try {
            for (var _d = true, _e = __asyncValues(explainFn.execute()), _f; _f = await _e.next(), _a = _f.done, !_a;) {
                _c = _f.value;
                _d = false;
                try {
                    const token = _c;
                    response.push(token);
                    this.emit('token', token);
                }
                finally {
                    _d = true;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (!_d && !_a && (_b = _e.return)) await _b.call(_e);
            }
            finally { if (e_1) throw e_1.error; }
        }
        this.history.saveMessage({ content: response.join(''), role: 'assistant' });
        this.emit('complete');
    }
}
exports.default = LocalNavie;
//# sourceMappingURL=navie-local.js.map