"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const console_1 = require("console");
const assert_1 = __importDefault(require("assert"));
const interaction_history_1 = require("../interaction-history");
const prompt_1 = require("../prompt");
class ApplyContextService {
    constructor(interactionHistory) {
        this.interactionHistory = interactionHistory;
    }
    applyContext(context, help, characterLimit) {
        if (!context) {
            this.interactionHistory.addEvent(new interaction_history_1.PromptInteractionEvent('contextLookup', 'system', 'No matching context information was found'));
            return;
        }
        const { sequenceDiagrams, codeSnippets, codeObjects } = context;
        const availableContent = new Array();
        const availableDiagrams = [...sequenceDiagrams];
        const availableCodeSnippets = Object.keys(codeSnippets).map((key) => [
            key,
            codeSnippets[key],
        ]);
        const availableDataRequests = [...codeObjects];
        const availableHelp = [...help];
        const availableItemCount = () => [
            availableDiagrams.length,
            availableCodeSnippets.length,
            availableDataRequests.length,
            availableHelp.length,
        ].reduce((a, b) => a + b, 0);
        // Select items in a round-robin fashion, to ensure a mix of content types. Heuristically, we
        // want to see one sequence diagram, N code snippets, and M data requests. If we run out of
        // one type of content type, we'll continue adding the other types.
        const numDiagrams = 1;
        const numSnippets = 7;
        const numDataRequests = 2;
        const numHelp = 1;
        const roundSize = numDiagrams + numSnippets + numDataRequests + numHelp;
        let index = 0;
        while (availableItemCount() > 0) {
            const itemType = index % roundSize;
            index += 1;
            let item;
            let name;
            let content;
            let file;
            const selectDiagram = () => {
                if (availableDiagrams.length === 0)
                    return false;
                name = prompt_1.PROMPTS[prompt_1.PromptType.SequenceDiagram].prefix;
                content = availableDiagrams.shift();
                return true;
            };
            const selectCodeSnippet = () => {
                if (availableCodeSnippets.length === 0)
                    return false;
                name = prompt_1.PROMPTS[prompt_1.PromptType.CodeSnippet].prefix;
                item = availableCodeSnippets.shift();
                (0, assert_1.default)(item);
                [file, content] = item;
                return true;
            };
            const selectDataRequest = () => {
                if (availableDataRequests.length === 0)
                    return false;
                name = prompt_1.PROMPTS[prompt_1.PromptType.DataRequest].prefix;
                content = availableDataRequests.shift();
                return true;
            };
            const selectHelp = () => {
                if (availableHelp.length === 0)
                    return false;
                const helpItem = availableHelp.shift();
                if (!helpItem)
                    return false;
                name = prompt_1.PROMPTS[prompt_1.PromptType.HelpDoc].prefix;
                [file, content] = [helpItem.filePath, helpItem.content];
                return true;
            };
            let selectionMade;
            if (itemType === 0) {
                selectionMade = selectDiagram();
            }
            else if (itemType >= numDiagrams && itemType < numDiagrams + numSnippets) {
                selectionMade = selectCodeSnippet();
            }
            else if (itemType >= numDiagrams + numSnippets &&
                itemType < numDiagrams + numSnippets + numDataRequests) {
                selectionMade = selectDataRequest();
            }
            else {
                selectionMade = selectHelp();
            }
            if (selectionMade) {
                (0, assert_1.default)(name && content);
                availableContent.push({ name, content, file });
            }
        }
        let charsRemaining = characterLimit;
        (0, console_1.log)(`Remaining characters before context: ${charsRemaining}`);
        const messages = new Array();
        const addContextItem = (contextItem) => {
            if (!contextItem)
                return false;
            // TODO: If the first content item is bigger than charsRemaining, no context can be added.
            // This can happen if the "micro" AppMap is still too big.
            if (charsRemaining - contextItem.content.length < 0)
                return false;
            charsRemaining -= contextItem.content.length;
            this.interactionHistory.addEvent(new interaction_history_1.ContextItemEvent({ name: contextItem.name, content: contextItem.content }, contextItem.file));
            messages.push(contextItem);
            return true;
        };
        // The sequence diagram may be too big to fit; in that case, continue with code snippets.
        addContextItem(availableContent.shift());
        for (const contextItem of availableContent) {
            if (!addContextItem(contextItem))
                break;
        }
        this.interactionHistory.log(`Remaining characters after context: ${charsRemaining}`);
    }
    addSystemPrompts(context, help) {
        const { sequenceDiagrams, codeSnippets, codeObjects } = context;
        if (sequenceDiagrams.length > 0)
            this.interactionHistory.addEvent(new interaction_history_1.PromptInteractionEvent(prompt_1.PromptType.SequenceDiagram, 'system', (0, prompt_1.buildPromptDescriptor)(prompt_1.PromptType.SequenceDiagram)));
        if (Object.keys(codeSnippets).length > 0)
            this.interactionHistory.addEvent(new interaction_history_1.PromptInteractionEvent(prompt_1.PromptType.CodeSnippet, 'system', (0, prompt_1.buildPromptDescriptor)(prompt_1.PromptType.CodeSnippet)));
        if (codeObjects.length > 0)
            this.interactionHistory.addEvent(new interaction_history_1.PromptInteractionEvent(prompt_1.PromptType.DataRequest, 'system', (0, prompt_1.buildPromptDescriptor)(prompt_1.PromptType.DataRequest)));
        if (help.length > 0)
            this.interactionHistory.addEvent(new interaction_history_1.PromptInteractionEvent(prompt_1.PromptType.HelpDoc, 'system', (0, prompt_1.buildPromptDescriptor)(prompt_1.PromptType.HelpDoc)));
    }
}
exports.default = ApplyContextService;
