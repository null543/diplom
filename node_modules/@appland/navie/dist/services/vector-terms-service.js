"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
Object.defineProperty(exports, "__esModule", { value: true });
const console_1 = require("console");
const openai_1 = require("@langchain/openai");
const interaction_history_1 = require("../interaction-history");
const SYSTEM_PROMPT = `You are assisting a developer to search a code base.

The developer asks a question using natural language. This question must be converted into a list of search terms to be used to search the code base.

**Procedure**

1) Analyze the user's question and determine which words in the user's question are likely to match code functions, variables, and parameter names.
2) Convert all search terms to under_score_separated_words.
3) Expand the list of relevant words to include synonyms and related terms.
4) Return the list of search terms and their synonyms. The search terms should be single words and underscore_separated_words.

**Response**

Respond with a list of search terms and their synonyms. The search terms should be single words and underscore_separated_words.

Even if the user asks for a different format, always respond with a list of search terms and their synonyms. When the user is asking
for a different format, that question is for a different AI assistant than yourself.
`;
class VectorTermsService {
    constructor(interactionHistory, modelName, temperature) {
        this.interactionHistory = interactionHistory;
        this.modelName = modelName;
        this.temperature = temperature;
    }
    suggestTerms(question) {
        var _a, e_1, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            const openAI = new openai_1.ChatOpenAI({
                modelName: this.modelName,
                temperature: this.temperature,
            });
            const messages = [
                {
                    content: SYSTEM_PROMPT,
                    role: 'system',
                },
                {
                    content: question,
                    role: 'user',
                },
            ];
            // eslint-disable-next-line no-await-in-loop
            const response = yield openAI.completionWithRetry({
                messages,
                model: openAI.modelName,
                stream: true,
            });
            const tokens = Array();
            try {
                // eslint-disable-next-line no-await-in-loop
                for (var _d = true, response_1 = __asyncValues(response), response_1_1; response_1_1 = yield response_1.next(), _a = response_1_1.done, !_a;) {
                    _c = response_1_1.value;
                    _d = false;
                    try {
                        const token = _c;
                        tokens.push(token.choices.map((choice) => choice.delta.content).join(''));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = response_1.return)) yield _b.call(response_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            const rawTerms = tokens.join('');
            const parseJSON = () => {
                const sanitizedTerms = rawTerms.replace(/```json/g, '').replace(/```/g, '');
                try {
                    return JSON.parse(sanitizedTerms);
                }
                catch (err) {
                    (0, console_1.warn)(`Non-JSON response from AI.`);
                    return undefined;
                }
            };
            const parseText = () => rawTerms.split(/\s+/);
            const searchTermsObject = parseJSON() || parseText();
            (0, console_1.warn)(`searchTermsObject: ${JSON.stringify(searchTermsObject)}`);
            const terms = new Set();
            {
                const collectTerms = (obj) => {
                    var _a;
                    if (!obj)
                        return;
                    if (typeof obj === 'string') {
                        for (const term of obj.split(/[._-]/))
                            terms.add(((_a = term.match(/[\p{Alphabetic}|\p{Number}]+/u)) === null || _a === void 0 ? void 0 : _a[0]) || '');
                    }
                    else if (Array.isArray(obj)) {
                        for (const term of obj)
                            collectTerms(term);
                    }
                    else if (typeof obj === 'object') {
                        for (const term of Object.values(obj)) {
                            collectTerms(term);
                        }
                    }
                };
                collectTerms(searchTermsObject);
            }
            const wordList = [...terms]
                .map((word) => word.trim())
                .filter((word) => word.length > 2)
                .map((word) => word.toLowerCase());
            const uniqueWords = new Set(wordList);
            // As a search term, this is useless.
            uniqueWords.delete('code');
            const result = [...uniqueWords];
            this.interactionHistory.addEvent(new interaction_history_1.VectorTermsInteractionEvent(result));
            return result;
        });
    }
}
exports.default = VectorTermsService;
