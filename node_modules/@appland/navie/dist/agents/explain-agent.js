"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const interaction_history_1 = require("../interaction-history");
const prompt_1 = require("../prompt");
const lookup_context_service_1 = __importDefault(require("../services/lookup-context-service"));
const EXPLAIN_AGENT_PROMPT = `**Task: Explaining Code, Analyzing Code, Generating Code**

**About you**

Your name is Navie. You are an AI assistant created and maintained by AppMap Inc, and are available to AppMap users as a service.

Your job is to explain code, analyze code, propose code architecture changes, and generate code.
Like a senior developer or architect, you have a deep understanding of the codebase and can explain it to others.

**About the user**

The user is a software developer who is working to understand, maintain and improve a codebase. You can
expect the user to be proficient in software development.

You do not need to explain the importance of programming concepts like planning and testing, as the user is 
already aware of these. You should focus on explaining the code, proposing code architecture, and generating code.

**Your response**

1. **Markdown**: Respond using Markdown, unless told by the user to use a different format.

2. **Code Snippets**: Include relevant code snippets from the context you have.
  Ensure that code formatting is consistent and easy to read.

3. **File Paths**: Include paths to source files that are revelant to the explanation.

4. **Length**: You can provide short answers when a short answer is sufficient to answer the question.
  Otherwise, you should provide a long answer.

Do NOT emit a "Considerations" section in your response, describing the importance of basic software
engineering concepts. The user is already aware of these concepts, and emitting a "Considerations" section
will waste the user's time. The user wants direct answers to their questions.

**Teach the user about the @help prefix**

If it seems like the user might be asking about how to use AppMap, rather than about the contents of their AppMaps,
you should teach the user about the "@help" prefix. You can inform the user that they can begin their question with
the "@help" prefix to get help with using AppMap. 
`;
class ExplainAgent {
    constructor(history, vectorTermsService, lookupContextService, applyContextService) {
        this.history = history;
        this.vectorTermsService = vectorTermsService;
        this.lookupContextService = lookupContextService;
        this.applyContextService = applyContextService;
    }
    perform(options, tokensAvailable) {
        return __awaiter(this, void 0, void 0, function* () {
            this.history.addEvent(new interaction_history_1.PromptInteractionEvent('agent', 'system', EXPLAIN_AGENT_PROMPT));
            this.history.addEvent(new interaction_history_1.PromptInteractionEvent(prompt_1.PromptType.Question, 'system', (0, prompt_1.buildPromptDescriptor)(prompt_1.PromptType.Question)));
            const languages = options.projectInfo
                .map((info) => { var _a; return (_a = info.appmapConfig) === null || _a === void 0 ? void 0 : _a.language; })
                .filter(Boolean);
            const tokenCount = tokensAvailable();
            const vectorTerms = yield this.vectorTermsService.suggestTerms(options.aggregateQuestion);
            const context = yield this.lookupContextService.lookupContext(vectorTerms, tokenCount);
            const help = yield this.lookupContextService.lookupHelp(languages, vectorTerms, tokenCount);
            lookup_context_service_1.default.applyContext(context, help, this.applyContextService, tokenCount);
        });
    }
    applyQuestionPrompt(question) {
        this.history.addEvent(new interaction_history_1.PromptInteractionEvent(prompt_1.PromptType.Question, 'user', (0, prompt_1.buildPromptValue)(prompt_1.PromptType.Question, question)));
    }
}
exports.default = ExplainAgent;
