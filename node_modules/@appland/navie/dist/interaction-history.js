"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContextItemEvent = exports.HelpLookupEvent = exports.ContextLookupEvent = exports.CompletionEvent = exports.VectorTermsInteractionEvent = exports.PromptInteractionEvent = exports.isPromptEvent = exports.InteractionEvent = void 0;
const events_1 = __importDefault(require("events"));
const interaction_state_1 = __importDefault(require("./interaction-state"));
const message_1 = require("./message");
const SNIPPET_LENGTH = 800;
function contentSnippet(content, maxLength = SNIPPET_LENGTH) {
    if (content.length < maxLength)
        return content;
    return `${content.slice(0, maxLength)}... (${content.length})`;
}
class InteractionEvent {
    constructor(type) {
        this.type = type;
    }
}
exports.InteractionEvent = InteractionEvent;
function isPromptEvent(event) {
    return event.type === 'prompt';
}
exports.isPromptEvent = isPromptEvent;
class PromptInteractionEvent extends InteractionEvent {
    constructor(name, role, content, prefix) {
        super('prompt');
        this.name = name;
        this.role = role;
        this.content = content;
        this.prefix = prefix;
    }
    get metadata() {
        return {
            type: this.type,
            role: this.role,
            name: this.name,
        };
    }
    get message() {
        return `[prompt] ${this.role}: ${contentSnippet(this.fullContent)}`;
    }
    get fullContent() {
        return [this.prefix, this.content].filter(Boolean).join(' ');
    }
    updateState(state) {
        state.messages.push({ content: this.fullContent, role: this.role });
    }
}
exports.PromptInteractionEvent = PromptInteractionEvent;
class VectorTermsInteractionEvent extends InteractionEvent {
    constructor(terms) {
        super('vectorTerms');
        this.terms = terms;
    }
    get metadata() {
        return {
            type: this.type,
            termCount: this.terms.length,
        };
    }
    get message() {
        return `[vectorTerms] ${this.terms.join(' ')}`;
    }
    updateState(state) {
        for (const term of this.terms)
            state.vectorTerms.push(term);
    }
}
exports.VectorTermsInteractionEvent = VectorTermsInteractionEvent;
class CompletionEvent extends InteractionEvent {
    constructor(model, temperature) {
        super('completion');
        this.model = model;
        this.temperature = temperature;
    }
    get metadata() {
        return {
            type: this.type,
            model: this.model,
            temperature: this.temperature,
        };
    }
    get message() {
        return `[completion] ${this.model} ${this.temperature}`;
    }
    updateState(state) {
        state.completionModel = this.model;
        state.completionTemperature = this.temperature;
    }
}
exports.CompletionEvent = CompletionEvent;
class ContextLookupEvent extends InteractionEvent {
    constructor(context) {
        super('contextLookup');
        this.context = context;
    }
    get contextAvailable() {
        return !!this.context;
    }
    get metadata() {
        return {
            type: this.type,
            contextAvailable: this.contextAvailable,
        };
    }
    get message() {
        if (!this.context)
            return `[contextLookup] not found`;
        const diagramCount = this.context.sequenceDiagrams.length;
        const snippetCount = Object.keys(this.context.codeSnippets).length;
        const dataRequestCount = this.context.codeObjects.length;
        return `[contextLookup] ${diagramCount} diagrams, ${snippetCount} snippets, ${dataRequestCount} data requests`;
    }
    updateState(state) {
        state.contextAvailable = this.context;
    }
}
exports.ContextLookupEvent = ContextLookupEvent;
class HelpLookupEvent extends InteractionEvent {
    constructor(help) {
        super('helpLookup');
        this.help = help;
    }
    get helpAvailable() {
        return !!this.help;
    }
    get metadata() {
        return {
            type: this.type,
            helpAvailable: this.helpAvailable,
        };
    }
    get message() {
        if (!this.help)
            return `[helpLookup] not found`;
        return `[helpLookup] ${this.help.length} items`;
    }
    updateState(state) {
        state.helpAvailable = this.help;
    }
}
exports.HelpLookupEvent = HelpLookupEvent;
class ContextItemEvent extends InteractionEvent {
    constructor(contextItem, file) {
        super('contextItem');
        this.contextItem = contextItem;
        this.file = file;
    }
    get metadata() {
        const result = {
            type: this.type,
            name: this.contextItem.name,
        };
        if (this.file) {
            result.file = this.file;
        }
        return result;
    }
    get message() {
        return [
            `[${this.contextItem.name}]`,
            this.file ? `${this.file}: ` : undefined,
            contentSnippet(this.contextItem.content),
        ]
            .filter(Boolean)
            .join(' ');
    }
    updateState(state) {
        const content = [
            `[${this.contextItem.name}]`,
            [this.file, this.contextItem.content].filter(Boolean).join(': '),
        ]
            .filter(Boolean)
            .join(' ');
        state.messages.push({ content, role: 'user' });
    }
}
exports.ContextItemEvent = ContextItemEvent;
class InteractionHistory extends events_1.default {
    constructor() {
        super(...arguments);
        this.events = [];
    }
    // eslint-disable-next-line class-methods-use-this
    log(message) {
        console.log(message);
    }
    addEvent(event) {
        this.emit('event', event);
        this.events.push(event);
    }
    clear() {
        this.events.splice(0, this.events.length);
    }
    computeTokenSize() {
        const state = this.buildState();
        const tokenCharacters = state.messages
            .map((message) => message.content.length)
            .reduce((a, b) => a + b, 0);
        return Math.round(tokenCharacters / message_1.CHARACTERS_PER_TOKEN);
    }
    buildState() {
        const state = new interaction_state_1.default();
        for (const event of this.events) {
            event.updateState(state);
        }
        return state;
    }
}
exports.default = InteractionHistory;
